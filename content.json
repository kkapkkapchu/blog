{"meta":{"title":"깝깝츄의 개발일기","subtitle":"코딩왕","description":null,"author":"깝깝츄","url":"https://kkapkkapchu.github.io/blog"},"pages":[{"title":"About","date":"2018-12-07T08:23:35.806Z","updated":"2018-12-07T08:23:35.806Z","comments":true,"path":"about/index.html","permalink":"https://kkapkkapchu.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-12-07T08:23:35.815Z","updated":"2018-12-07T08:23:35.815Z","comments":true,"path":"tags/index.html","permalink":"https://kkapkkapchu.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-12-07T08:23:35.809Z","updated":"2018-12-07T08:23:35.809Z","comments":true,"path":"categories/index.html","permalink":"https://kkapkkapchu.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"[HTML] 폭 없는 공백","slug":"html_zero_width_space","date":"2019-01-03T06:23:00.000Z","updated":"2019-01-03T06:42:31.862Z","comments":true,"path":"2019/01/03/html_zero_width_space/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2019/01/03/html_zero_width_space/","excerpt":"","text":"폭 없는 공백유니코드에서 폭 없는 공백은 U+200B (HTML: &amp;#8203;) 에 할당되어있다. 커서 위치 지정폭 없는 공백을 사용하면 커서 위치를 지정할 때 아주 유용하다. 에디터에서 colorPicker 로 색상 변경 시 선택된 텍스트의 색상을 바꿀 때contenteditable 안에 스타일을 입힌 span 태그를 추가하도록 구현했다. 이때 span 안의 내용이 빈 값이면 커서가 인식을 못하는 문제가 있었다.그래서 텍스트의 선택된 범위가 없다면 span 안에 빈 값(&#39;&#39;) 대신 &amp;#8203; 을 넣어주고 커서 위치를 저장했다가 복구시키니 잘 동작하는 것을 확인했다. 이거 때문에 한참동안 헤맸는데..다음엔 더 유용하게 사용할 수 있기를.. 123456789saveCaret(node); // 커서 위치 저장const range = window.getSelection().getRangeAt(0);const colorElement = document.createElement(\"span\");colorElement.style = `color:$&#123;color&#125;`;colorElement.innerHTML = isSelected ? selectedText : \"&amp;#8203;\"; // 폭 없는 공백restoreCaret(node); // 커서 위치 복구","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"HTML","slug":"Web/HTML","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/HTML/"}],"tags":[{"name":"cursor","slug":"cursor","permalink":"https://kkapkkapchu.github.io/blog/tags/cursor/"},{"name":"ZWSP","slug":"ZWSP","permalink":"https://kkapkkapchu.github.io/blog/tags/ZWSP/"},{"name":"span","slug":"span","permalink":"https://kkapkkapchu.github.io/blog/tags/span/"}]},{"title":"[Javascript] Span 태그에 text 넣기","slug":"javascript_span_set_text","date":"2019-01-03T06:23:00.000Z","updated":"2019-01-03T06:26:48.720Z","comments":true,"path":"2019/01/03/javascript_span_set_text/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2019/01/03/javascript_span_set_text/","excerpt":"","text":"Span 태그에 text 넣기span 태그에 text 를 넣는 방법은 두 가지가 있다. 1document.getElementById(\"myspan\").innerHTML = \"newtext\"; 1document.getElementById(\"myspan\").textContent = \"newtext\"; // for mordern browsers 필요에 따라 선택해서 사용하면 된다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"span","slug":"span","permalink":"https://kkapkkapchu.github.io/blog/tags/span/"},{"name":"text","slug":"text","permalink":"https://kkapkkapchu.github.io/blog/tags/text/"}]},{"title":"[Javascript] contenteditable 의 커서 위치 저장/복구 하기","slug":"javascript_contenteditable_save&restore_cursor","date":"2019-01-03T06:03:00.000Z","updated":"2019-01-03T06:21:30.655Z","comments":true,"path":"2019/01/03/javascript_contenteditable_save&restore_cursor/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2019/01/03/javascript_contenteditable_save&restore_cursor/","excerpt":"","text":"contenteditable 의 커서 위치 저장/복구 안됐던 이유지난번에 contenteditable 커서 관련하여 쓴 글이 있다. 이 때는 커서 위치를 저장하고 복구 시키려다가 실패해서 결국 맨 끝으로 보내게 했는데안 되었던 이유를 알았다. 그것은 바로 contenteditable 의 내용(innerHTML/innerText) 을 바꾸기 전에 입력 창을 blur 시키고, 바꾸고 나서 커서 위치를 복구 시킬때 focus 를 강제로 해줘야 하는데 안해서 그랬던 것!!! 사실 문서에 다 써있었는데 대충 읽어서 그 부분만 빼고 테스트하다 실패한 것..ㅠ문서 좀 제대로 읽자…! contenteditable 의 커서 위치 저장/복구 하기커서 위치 저장/복구 하는 방법은 여기에 아주 잘 나와있다.그대로만 따라하면 잘 됨. 나는 set/get 의 의미가 좀 헷갈려서 save/restore 로 바꾸었다.그리고 restore 할 때 에러가 발생하는 경우가 있어서 추가로 예외처리를 해주었다. 1234567891011121314151617181920212223242526272829saveCaret(node) &#123; const caretID = 'caret' const cc = document.createElement('span') cc.id = caretID window .getSelection() .getRangeAt(0) .insertNode(cc) node.blur()&#125;,restoreCaret(node) &#123; const caretID = 'caret' const range = document.createRange() const cc = document.getElementById(caretID) node.focus() if (!cc) &#123; return &#125; range.selectNode(cc) const selection = window.getSelection() selection.removeAllRanges() selection.addRange(range) range.deleteContents()&#125; 내용을 바꾸기 전에 saveCaret 으로 마지막 선택된 커서 위치를 저장하고내용을 바꾼 후 restoreCaret 으로 커서 위치를 복구시킨다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"contenteditable","slug":"contenteditable","permalink":"https://kkapkkapchu.github.io/blog/tags/contenteditable/"},{"name":"cursor","slug":"cursor","permalink":"https://kkapkkapchu.github.io/blog/tags/cursor/"},{"name":"caret","slug":"caret","permalink":"https://kkapkkapchu.github.io/blog/tags/caret/"}]},{"title":"[CSS] Invalid property value","slug":"css_invalid_property_value","date":"2019-01-03T05:47:00.000Z","updated":"2019-01-03T06:22:42.134Z","comments":true,"path":"2019/01/03/css_invalid_property_value/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2019/01/03/css_invalid_property_value/","excerpt":"","text":"CSS 속성에 Invalid property value 가 뜰 때마크업 작업을 하다가 분명히 margin-top 속성을 줬는데 속성이 먹히지도 않고개발자 도구로 보면 노란색 느낌표가 뜨면서 해당 속성에 취소선이 그어져 있다. 느낌표에 마우스를 갖다대면 Invalid property value 라는 툴팁이 뜬다. 하… 진짜 이거때매 한참을 헤맸는데… ㅠㅠ 리액트를 너무 오래썼나보다..리액트 문법을 css 에서 사용하니 당연히 안되지 ㅠ.ㅠ 1234div &#123; margin-top: \"33px\"; // 이렇게 쓰면 사진처럼 나오고 속성이 안먹힘 ㅠㅠ margin-top: 33px; // 이렇게 써야함!!&#125; css 에서는 &#39;&#39;로 감싸지 않고 바로 33px 쓰면 된다. 앞으로 또 저런 이슈를 보게 되면 속성을 잘못 사용하지 않았는지 꼭 확인해보자!","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"CSS","slug":"Web/CSS","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/CSS/"}],"tags":[{"name":"property","slug":"property","permalink":"https://kkapkkapchu.github.io/blog/tags/property/"}]},{"title":"[Vuex] Error: getters should be function","slug":"vuex_getters_should_be_function","date":"2018-12-13T05:10:00.000Z","updated":"2018-12-13T05:28:04.208Z","comments":true,"path":"2018/12/13/vuex_getters_should_be_function/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/12/13/vuex_getters_should_be_function/","excerpt":"","text":"Vuex - store 와 모듈Vuex 에서 store를 정의하려면 Vuex.Store() 로 store 인스턴스를 생성해야 한다. 123import Vuex from 'vuex'const store = new Vuex.Store(&#123; ...options &#125;) ...options 부분에는 state, getters, mutations, actions 등이 들어간다. store 에 정의할 것이 많아지면 모듈화를 하게 되는데 이 때 store 인스턴스가 두 번 생성되지 않도록 조심해야 한다. 모듈화를 할 때는 store 인스턴스를 내보내는 index.js 한 군데에서만 하면 된다. 각 모듈 안에서 store 인스턴스를 또 생성하게 되면 아래와 같은 에러가 발생한다. 결론해당 에러 발생 시 Vuex.Store() 가 중복되어 사용되지 않았는지 확인해 볼 것.store 인스턴스는 한 번만 생성한다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Vue","slug":"Web/Vue","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Vue/"},{"name":"Vuex","slug":"Web/Vue/Vuex","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Vue/Vuex/"}],"tags":[{"name":"getters","slug":"getters","permalink":"https://kkapkkapchu.github.io/blog/tags/getters/"}]},{"title":"[Javascript] axios 로 API 호출 시 request params 보내기","slug":"javascript_library_axios_params","date":"2018-12-10T05:31:00.000Z","updated":"2018-12-10T05:58:42.647Z","comments":true,"path":"2018/12/10/javascript_library_axios_params/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/12/10/javascript_library_axios_params/","excerpt":"","text":"axios 라이브러리axios 라이브러리가 뭔지는 git 주소 를 참고하자. axios 로 API 호출하기 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) axios 로 API 호출 시 request params 보내기request params 은 path 뒤에 붙게 되는 쿼리 파라미터를 뜻한다. request params 는 전달 인자의 config 부분에 넣어주면 된다. 12345678910111213// GET / DELETEaxios.get(url, &#123; params: &#123; key: value &#125;&#125;)// POST / PUTaxios.post(url, data, &#123; params: &#123; key: value &#125;&#125;) body 에 보낼 data 가 없다면 빈 값(‘’)으로 보내주면 된다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"},{"name":"Library","slug":"Web/Javascript/Library","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/Library/"}],"tags":[{"name":"axios","slug":"axios","permalink":"https://kkapkkapchu.github.io/blog/tags/axios/"},{"name":"params","slug":"params","permalink":"https://kkapkkapchu.github.io/blog/tags/params/"}]},{"title":"[Javascript] contenteditable 에 복사한 데이터 붙여넣을 때 텍스트만 넣기 (IE 지원)","slug":"javascript_contenteditable_copy&paste_IE","date":"2018-10-24T06:28:00.000Z","updated":"2018-12-07T08:23:35.791Z","comments":true,"path":"2018/10/24/javascript_contenteditable_copy&paste_IE/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/10/24/javascript_contenteditable_copy&paste_IE/","excerpt":"","text":"아래 코드는 contenteditable 에 복사한 데이터 붙여넣을 때 텍스트만 넣고 싶을 때 IE 도 지원하는 코드이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748insertText(text) &#123; // use insertText command if supported if (document.queryCommandSupported('insertText')) &#123; document.execCommand('insertText', false, text); &#125; // or insert the text content at the caret's current position // replacing eventually selected content else &#123; // for IE let range = document.getSelection().getRangeAt(0); range.deleteContents(); let textNode = document.createTextNode(text); range.insertNode(textNode); range.selectNodeContents(textNode); range.collapse(false); let selection = window.getSelection(); selection.removeAllRanges(); selection.addRange(range); &#125;&#125;;/** * 텍스트를 붙여넣기 할 때 발생하는 함수입니다. */handlePaste = (event) =&gt; &#123; event.preventDefault(); let pasteText = \"\"; let agent = navigator.userAgent.toLowerCase(); if ( (navigator.appName == 'Netscape' &amp;&amp; agent.indexOf('trident') != -1) || (agent.indexOf(\"msie\") != -1)) &#123; // ie일 경우 pasteText = window.clipboardData.getData('Text'); &#125; else &#123; // ie가 아닐 경우 pasteText = (event.originalEvent || event).clipboardData.getData('text/plain'); &#125; this.insertText(pasteText);&#125;render() &#123; return ( &lt;p contenteditable=\"true\" onPaste=&#123;this.handlePaste&#125;&gt; This is a paragraph. It is editable. Try to change this text. &lt;/p&gt; )&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"IE","slug":"IE","permalink":"https://kkapkkapchu.github.io/blog/tags/IE/"},{"name":"contenteditable","slug":"contenteditable","permalink":"https://kkapkkapchu.github.io/blog/tags/contenteditable/"},{"name":"copy&paste","slug":"copy-paste","permalink":"https://kkapkkapchu.github.io/blog/tags/copy-paste/"},{"name":"execCommand","slug":"execCommand","permalink":"https://kkapkkapchu.github.io/blog/tags/execCommand/"}]},{"title":"[Javascript] contenteditable 에 복사한 데이터 붙여넣을 때 텍스트만 넣기","slug":"javascript_contenteditable_copy&paste","date":"2018-10-17T08:02:00.000Z","updated":"2018-12-07T08:23:35.789Z","comments":true,"path":"2018/10/17/javascript_contenteditable_copy&paste/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/10/17/javascript_contenteditable_copy&paste/","excerpt":"","text":"contenteditable 에 복사한 데이터를 붙여넣으면 복사했을 때의 스타일(CSS)까지 그대로 적용된다.아래 코드를 실행시키고 스타일이 들어간 텍스트를 복사&amp;붙여넣기 해보자. 1234567render() &#123; return ( &lt;p contenteditable=\"true\"&gt; This is a paragraph. It is editable. Try to change this text. &lt;/p&gt; )&#125; 결과는 다음과 같이 나올 것이다. 이렇게 나오면 안되기 때문에 텍스트만 붙여넣을 수 있도록 작업을 해줘야 한다.아래와 같이 하면 된다. 1234567891011121314151617/** * 텍스트를 붙여넣기 할 때 발생하는 함수입니다. */handlePaste = (event) =&gt; &#123; event.preventDefault(); let pasteText = (event.originalEvent || event).clipboardData.getData('text/plain'); window.document.execCommand('insertText', false, pasteText);&#125;render() &#123; return ( &lt;p contenteditable=\"true\" onPaste=&#123;this.handlePaste&#125;&gt; This is a paragraph. It is editable. Try to change this text. &lt;/p&gt; )&#125; 이렇게 붙여넣기 이벤트를 잡아서 preventDefault로 기본 동작을 막고 execCommand 처리를 해주면 아래 사진과 같이 텍스트만 잘 나오게 된다. 하지만 위의 방식은 IE를 지원하지 않는다. IE 를 지원하는 방법은 다음 포스팅을 참고하자.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"contenteditable","slug":"contenteditable","permalink":"https://kkapkkapchu.github.io/blog/tags/contenteditable/"},{"name":"copy&paste","slug":"copy-paste","permalink":"https://kkapkkapchu.github.io/blog/tags/copy-paste/"},{"name":"execCommand","slug":"execCommand","permalink":"https://kkapkkapchu.github.io/blog/tags/execCommand/"}]},{"title":"[Javascript] contenteditable 의 커서 맨 뒤로 보내기","slug":"javascript_contenteditable_set_cursor_to_end","date":"2018-10-17T05:17:00.000Z","updated":"2018-12-07T08:23:35.792Z","comments":true,"path":"2018/10/17/javascript_contenteditable_set_cursor_to_end/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/10/17/javascript_contenteditable_set_cursor_to_end/","excerpt":"","text":"contenteditable 속성을 사용하면 표준 HTML5 요소들이 편집 가능한 상태가 된다. 댓글 컴포넌트를 개발하면서 div 에 contenteditable 속성을 사용했다.이유는 글자 수가 늘어날수록 입력창도 같이 늘어나기 때문. 개발하면서 몇 가지 이슈가 있었는데 정리해보자. 발생했던 이슈 contenteditable 속성을 사용한 div 내부에 힌트텍스트 span 요소가 들어감 keydown/keyup 에서 한글은 preventDefault() 가 안먹힘 contenteditable 의 커서 맨 뒤로 보내기 1. contenteditable 속성을 사용한 div 내부에 힌트텍스트 span 요소가 들어감댓글 내용이 비었을 때 댓글을 입력하라는 내용의 힌트텍스트를 보여주어야 했다.전달받은 퍼블리싱 결과물은 아래 코드의 구조처럼 되어있었다.1234567render() &#123; return ( &lt;div contenteditable&gt; &lt;span className=\"reply_placeholder\"&gt;댓글을 입력하세요.&lt;/span&gt; &lt;/div&gt; )&#125; 하지만 이렇게 하면 웹 브라우저 개발자 도구에서 아래 사진과 같은 오류가 발생한다. 리액트에서는 contenteditable 속성을 사용한 태그 안에 자식 요소를 넣으면 저렇게 warning 을 띄우나 보다. 이 이슈는 contenteditable 속성을 사용한 태그를 빈 태그로 사용하고,class=&quot;reply_placeholder&quot; 스타일을 position: absolute 해서 위치 잡는 것으로 바꿔달라고 요청해서 css 를 수정하는 것으로 해결했다. 12345678910render() &#123; return ( &lt;div className=\"reply_inputbox\" contentEditable dangerouslySetInnerHTML=&#123;&#123;__html: html&#125;&#125; &gt;&lt;/div&gt; &lt;span className=\"reply_placeholder\"&gt;댓글을 입력하세요.&lt;/span&gt; )&#125; 2. keydown/keyup 에서 한글은 preventDefault() 가 안먹힘컴포넌트 기획에 maxLength 가 있어 글자 수 초과시 입력을 막아야 했다.그런데 keydown/keyup 에서 한글은 preventDefault() 가 먹히질 않았다. 찾아보니 이유는 compositionstart -&gt; keydown 순서로 이벤트가 발생하기 때문에 한글이 이미 입력된 상태여서 preventDefault()를 해도 소용이 없었던 것.compositionstart 에서 preventDefault() 를 시도했으나 안됨… 한글 입력 자체를 막는 style=&quot;ime-mode:disabled&quot; 는 기본적인 크롬에서 지원 안하므로 패스. preventDefault() 가 되지 않으니 초과된 글자를 입력 후 keyup 에서 잘라내도록 했다.문제는 html 을 setState 하니까 안에 내용물이 바뀌게 되어서 글자 입력시마다 커서가 맨앞으로 이동하는 이슈가 생겼다. 이 이슈를 해결하기 위해 잘라내기 전 커서 위치를 저장하고 복원하는 방법을 여러가지 시도했지만결국 내용 자체가 바뀌게 되면서 기존에 저장해놨던 커서 위치가 날아감…ㅠ 3. contenteditable 의 커서 맨 뒤로 보내기결국 최대 글자 수 초과 시 얼럿을 띄우고 커서를 맨 뒤로 보내기로 했다. contenteditable 에서 커서를 맨 뒤로 보내는 방법은 아래 코드를 참고하면 된다. 123456789101112131415161718192021/** * 커서를 맨 뒤로 보내는 함수입니다. * @param contentEditableElement 커서를 움직일 노드입니다. */export function setEndOfContenteditable(contentEditableElement) &#123; let range,selection; if (document.createRange) &#123; //Firefox, Chrome, Opera, Safari, IE 9+ range = document.createRange(); //Create a range (a range is a like the selection but invisible) range.selectNodeContents(contentEditableElement);//Select the entire contents of the element with the range range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start selection = window.getSelection();//get the selection object (allows you to change selection) selection.removeAllRanges(); //remove any selections already made selection.addRange(range); //make the range you have just created the visible selection &#125; else if (document.selection) &#123; //IE 8 and lower range = document.body.createTextRange(); //Create a range (a range is a like the selection but invisible) range.moveToElementText(contentEditableElement); //Select the entire contents of the element with the range range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start range.select(); //Select the range (make it the visible selection &#125;&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"contenteditable","slug":"contenteditable","permalink":"https://kkapkkapchu.github.io/blog/tags/contenteditable/"},{"name":"cursor","slug":"cursor","permalink":"https://kkapkkapchu.github.io/blog/tags/cursor/"},{"name":"caret","slug":"caret","permalink":"https://kkapkkapchu.github.io/blog/tags/caret/"}]},{"title":"[Javascript] IE 브라우저 체크하기","slug":"javascript_check_ie_browser","date":"2018-10-17T05:11:00.000Z","updated":"2018-12-07T08:23:35.786Z","comments":true,"path":"2018/10/17/javascript_check_ie_browser/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/10/17/javascript_check_ie_browser/","excerpt":"","text":"개발하다 보면 IE 와 크롬이 동작이 달라서 브라우저를 체크해서 처리해야 할 경우가 있다. 아래 코드는 모든 IE일 경우 체크하게 하는 조건문이다. 123456let agent = navigator.userAgent.toLowerCase();if ( (navigator.appName == 'Netscape' &amp;&amp; agent.indexOf('trident') != -1) || (agent.indexOf(\"msie\") != -1)) &#123; // ie일 경우&#125; else &#123; // ie가 아닐 경우&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"IE","slug":"IE","permalink":"https://kkapkkapchu.github.io/blog/tags/IE/"}]},{"title":"[Javascript] replaceAll 하기","slug":"javascript_replaceall","date":"2018-10-17T05:05:00.000Z","updated":"2018-12-07T08:23:35.801Z","comments":true,"path":"2018/10/17/javascript_replaceall/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/10/17/javascript_replaceall/","excerpt":"","text":"자바스크립트에서 replaceAll 은 없다.정규식을 이용하여 대상 스트링에서 모든 부분을 수정해 줄 수 있다. replace 이용1234let str = \"aaa#bbb#ccc\";// #를 공백으로 변경한다.str.replace(\"#\",\"\"); // aaabbb#ccc replace 를 이용하면 첫 번째 # 만 공백으로 변경하고 나머지는 변경이 되지 않는다. 정규식을 이용해서 g로 감싸기12345let str = \"aaa#bbb#ccc\";// #를 감싼 따옴표를 슬래시(/)로 대체하고 뒤에 gi 를 붙이면 // replaceAll 과 같은 결과를 볼 수 있다.str.replace(/#/g, \"\"); // aaabbbccc 정규식 사용법 g : 발생할 모든 pattern에 대한 전역 검색 i : 대/소문자 구분 안함 m : 여러 줄 검색 (참고)","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"replace","slug":"replace","permalink":"https://kkapkkapchu.github.io/blog/tags/replace/"},{"name":"replaceall","slug":"replaceall","permalink":"https://kkapkkapchu.github.io/blog/tags/replaceall/"}]},{"title":"[Javascript] this에 대해","slug":"javascript_concept_this","date":"2018-10-04T11:17:00.000Z","updated":"2018-12-07T08:23:35.788Z","comments":true,"path":"2018/10/04/javascript_concept_this/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/10/04/javascript_concept_this/","excerpt":"","text":"this 란 무엇인가this 란 함수의 현재 실행 문맥이다.자바스크립트에는 4가지의 함수 실행 타입이 있다. 1) 함수 실행: alert(‘Hello World!’)2) 메소드 실행: console.log(‘Hello World!’)3) 생성자 실행: new RegExp(‘\\d’)4) 간접 실행: alert.call(undefined, ‘Hello World!’) 각각의 타입은 서로 다른 문맥을 가지며, 엄격 모드(strict mode) 역시 실행 문맥에 영향을 끼친다.this 를 이해하려면 함수 실행이 문맥에 어떤 영향을 미치는지 확실히 이해해야 한다.함수 호출이 this 에 어떤 영향을 미치는지 알아보자. 1. 함수 실행함수 실행은 alert(&#39;Hello World!&#39;) 와 같이 함수이름()으로 호출하는 것이다. 함수 실행에서의 this 는 전역 객체이다. 전역 객체는 실행 환경에 따라 결정된다. 웹 브라우저에서는 window가 전역 객체이다.함수 실행에서의 실행 문맥은 전역 객체이다. 123456789function sum(a, b) &#123; console.log(this === window); // =&gt; true this.myNumber = 20; // 전역 객체에 'myNumber'라는 속성을 추가 return a + b;&#125;// sum()은 함수 호출이다.// sum()에서의 this는 전역 객체다. (window)sum(15, 16); // =&gt; 31window.myNumber; // =&gt; 20 this가 함수 스코프 밖(최상단: 전역 실행 문맥)에서 사용되었을 경우, 여기서의 this 역시 전역 객체를 참조하게 된다.123console.log(this === window); // =&gt; truethis.myString = 'Hello World!';console.log(window.myString); // =&gt; 'Hello World!' 엄격 모드 엄격 모드에서 함수 실행에서의 this는 undefined 이다. 엄격 모드는 코드 안정성과 더 나은 오류 검증을 제공하기 위해 ECMA Script 5.1 버전에서 처음 소개 되었다. 엄격 모드로 작성하기 위해 함수 내부의 최상단에 ‘use strict’라는 예약어를 적는다. 이 모드는 실행 문맥인 this를 undefined로 만든다. 실행 문맥은 더이상 전역 객체로 되지 않고, 위의 케이스와 반대의 상황이 된다. 엄격 모드로 실행되는 예제 코드12345678function multiply(a, b) &#123; 'use strict'; // 엄격 모드 console.log(this === undefined); // =&gt; true return a * b;&#125;// multiply() 함수는 엄격 모드로 실행됨// multiply()에서의 this는 undefinedmultiply(2, 5); // =&gt; 10 multiply(2, 5) 함수가 실행될 때 this는 undefined다. 엄격 모드는 현재 스코프 뿐만 아니라 내부 스코프에서도 적용된다. (내부에 정의된 모든 함수에 적용됨) 내부 함수에서 this 를 사용할 때함수를 실행할 때 흔히 하는 실수가 외부 함수에서의 this와 내부 함수에서의 this를 동일하게 생각하는 것이다. 사실 내부 함수의 문맥은 외부 함수의 문맥에 의존되는 게 아니라 오직 실행 환경에 좌우된다. 기대하는 되로 this가 동작되려면 수정이 필요하다. (call이라 apply 메소드를 사용하는 간접 실행, 또는 바인딩 함수를 적용) 12345678910111213141516var numbers = &#123; numberA: 5, numberB: 10, sum: function() &#123; console.log(this === numbers); // =&gt; true function calculate() &#123; // this는 window, 엄격 모드였으면 undefined console.log(this === numbers); // =&gt; false return this.numberA + this.numberB; &#125; return calculate(); // 문맥을 수정하기 위해 .call() 메소드를 적용해야함 // return calculate.call(this); &#125;&#125;;numbers.sum(); // NaN, 엄격 모드였으면 TypeError 메소드 실행메소드는 객체의 속성으로 있는 함수이다. 1234567var myObject = &#123; // helloFunction is a method helloFunction: function() &#123; return 'Hello World!'; &#125;&#125;;var message = myObject.helloFunction(); // 메소드 실행 여기서 helloFunction는 myOjbect의 메소드다. 메소드에 접근하기 위해서는 myObject.helloFunction와 같은 속성 접근자를 이용하면 된다. 메소드 실행은 속성 접근자 형태의 표현식이 함수 객체로 계산되면서 실행된다. 앞서 설명한 함수 실행과 메소드 실행이 다르다는 점은 중요하다. 왜냐하면 둘은 서로 다른 타입이기 때문이다. 둘의 가장 큰 차이점은 메소드 실행은 속성 접근자를 통해 function (.functionProperty() or ‘functionProperty’)를 호출한다. 반면에 함수 실행은 속성 접근자를 사용하지 않고, (())와 같이 바로 호출한다. 메소드 실행에서의 this 메소드 실행에서의 this는 메소드를 소유하고 있는 객체이다. 객체 내에 있는 메소드를 실행할 때, 여기서의 this는 객체 자신이다.1234567891011var calc = &#123; num: 0, increment: function() &#123; console.log(this === calc); // =&gt; true this.num += 1; return this.num; &#125;&#125;;// 메소드 실행. 여기서의 this는 calc.calc.increment(); // =&gt; 1calc.increment(); // =&gt; 2 ECMAScript 6의 class 예약어에서 메소드 실행 문맥은 위와 마찬가지로 인스턴스 자신을 가리킨다.123456789101112class Planet &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; console.log(this === earth); // =&gt; true return this.name; &#125;&#125;var earth = new Planet('Earth');// 메소드 실행. 여기서의 this는 earth.earth.getName(); // =&gt; 'Earth' 객체로부터 메소드를 분리할 때객체 내에 있는 메소드는 별도의 변수로 분리할 수 있다. 이 변수를 통해 메소드를 호출할 때, 당신은 아마도 여기서의 this가 메소드가 정의되어있는 객체라고 생각할 것이다. 객체 밖에 있는 메소드를 호출할 경우, 함수 실행을 한 결과와 같다. 함수 실행을 할 경우 this는 전역 객체인 window를 가리킨다. (엄격 모드에서는 undefined) .bind() 바인딩 함수를 사용해서 문맥을 수정할 경우, 메소드를 객체에 포함시킬 수 있다. 123456789101112131415function Animal(type, legs) &#123; this.type = type; this.legs = legs; this.logInfo = function() &#123; console.log(this === myCat); // =&gt; false console.log('The ' + this.type + ' has ' + this.legs + ' legs'); &#125;&#125;var myCat = new Animal('Cat', 4);// \"The undefined has undefined legs\" 출력// 혹은 엄격모드라면 TypeError 출력setTimeout(myCat.logInfo, 1000);// .bind 메소드를 사용해 문맥을 강제로 지정시킬 수 있다// setTimeout(myCat.logInfo.bind(myCat), 1000); .bind 함수로 실행 문맥을 myCat 으로 지정해주면 함수 실행임에도 불구하고, 여기서의 this는 myCat을 가리키게 된다. 생성자 실행생성자 실행은 표현식 앞에 new라는 키워드가 붙었을 때, 함수 객체로 계산되어 수행된다. 생성자 실행에서의 this 는 새롭게 만들어진 객체이다. 생성자 실행에서의 문맥은 새롭게 만들어진 객체다. 생성자 실행은 객체에 초기값을 셋팅하기 위해 사용된다. 초기값 셋팅의 예로는 생성자 함수의 매개 변수로 받은 데이터, 속성을 위한 환경 변수, 이벤드 핸들러 등이 있다. 1234567function Foo () &#123; console.log(this instanceof Foo); // =&gt; true this.property = 'Default Value';&#125;// 생성자 실행var fooInstance = new Foo();fooInstance.property; // =&gt; 'Default Value' ES6에서 사용 가능한 class 문법 역시 같은 형식이다. 초기값 셋팅은 오직 생성자 메소드에서 할 수 있다.123456789class Bar &#123; constructor() &#123; console.log(this instanceof Bar); // =&gt; true this.property = 'Default Value'; &#125;&#125;// Constructor invocationvar barInstance = new Bar();barInstance.property; // =&gt; 'Default Value' 생성자를 호출할 때에는 꼭 new 연산자를 사용해야 한다. new 연산자를 사용하지 않으면 객체 안의 this는 함수 실행이 되므로 window 객체를 가리키게 된다. 그리고 Vehicle(‘Car’, 4)은 속성을 window 객체에 추가한다. 잘못된 사용이다. 새로운 객체가 만들어지지 않는다. 결론 this 는 함수의 실행 문맥이다. 함수 실행은 아래와 같이 4가지 타입으로 나뉘며, 이에 따라 함수의 실행 문맥이 달라진다. 함수 실행 / 엄격 모드 메소드 실행 생성자 실행 간접 실행 함수 실행에서의 this 는 전역 객체이다. 웹 브라우저에서는 window 이다. 엄격 모드에서 함수를 실행한다면, 이 함수의 this 는 undefined 이다. 메소드 실행에서의 this 는 메소드를 소유하는 객체이다. 생성자 실행에서의 this 는 새로 생성된 객체이다. 주의 - 메소드가 함수로 사용될 때 .bind 를 사용해 문맥 강제시키기. 주의 - 생성자 호출시에는 new 키워드 꼭 사용할 것. 참고 문서 자바스크립트에서 사용되는 this에 대한 설명 1","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"this","slug":"this","permalink":"https://kkapkkapchu.github.io/blog/tags/this/"}]},{"title":"[Javascript] 클로저(Closure)에 대해","slug":"javascript_concept_closure","date":"2018-07-07T14:02:00.000Z","updated":"2018-12-07T08:23:35.787Z","comments":true,"path":"2018/07/07/javascript_concept_closure/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/07/07/javascript_concept_closure/","excerpt":"","text":"클로저란 무엇인가함수 내부에 함수를 작성할 때마다 이미 클로저를 생성한 것이다.내부에 작성한 함수가 바로 클로저라닛!! 여태껏 클로저가 뭔지도 모르고 사용했다.. 12345678function outerFunction () &#123; const outer = 'I see the outer variable!' return function innerFunction() &#123; console.log(outer) &#125;&#125;outerFunction()() // I see the outer variable! 클로저를 왜 쓸까클로저는 외부함수의 변수에 접근이 가능하다. (자바스크립의 스코프를 이해한다면 당연한 것)때문에 일반적으로 두 가지의 목적이 있다. 사이드 이펙트(side effects) 제어하기 private 변수 생성하기(캡슐화) 사이드 이펙트(side effects) 제어하기함수에서 값을 반환할 때를 제외하고 무언가를 행할 때 사이드 이펙트(side effects)가 발생한다.여러 가지 것들이 사이드 이펙트가 될 수 있는데, 예를 들어 Ajax 요청이나 timeout을 생성할 때,그리고 심지어 console.log를 선언하는 것도 사이드 이펙트이다. 보통 Ajax나 timeout과 같이 코드 흐름을 방해하는 것들이 신경 쓰일 때,클로저를 활용하여 사이드 이펙트를 제어한다. 123456var i;for (i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100);&#125; 간단하게 0-9까지의 정수를 출력하는 코드이지만 실제로 돌려보면 엉뚱하게도 10만 열 번 출력되는 걸 볼 수 있다. 왜일까?먼저 setTimeout()에 인자로 넘긴 익명함수는 모두 0.1초 뒤에 호출될 것이다.그 0.1초 동안에 이미 반복문이 모두 순회되면서 i값은 이미 10이 된 상태.그 때 익명함수가 호출되면서 이미 10이 되어버린 i를 참조하는 것이다. 이 경우에도 클로저를 사용하면 원하는 대로 동작하도록 만들 수 있다. 12345678var i;for (i = 0; i &lt; 10; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 100); &#125;)(i);&#125; 중간에 즉시 실행 함수(IIFE)를 덧붙여 setTimeout()에 걸린 익명함수를 클로저로 만들었다.클로저는 만들어진 환경을 기억한다. 이 코드에서 i는 IIFE내에 j라는 형태로 주입되고, 클로저에 의해 각기 다른 환경속에 포함된다.반복문은 10회 반복되므로 10개의 환경이 생길 것이고, 10개의 서로 다른 환경에 10개의 서로 다른 j가 생긴다. 위의 예제에서는 IIFE를 통해서 클로저마다 환경이 생긴다.하지만 인자로 i를 넘기지 않는다면 당연히 클로저가 참조하는 IIFE의 함수 스코프에서도 i값이 없으므로 생성 당시의 외부 스코프인 글로벌을 탐색하게 되고 결국 모두 같은 i를 참조하게 된다.반면에, 인자로 i를 넘기게 되면 IIFE로 만든 10개의 스코프에 모두 i라는 변수가 다른 값으로 생기므로 정상적으로 동작할 수 있는 것이다. 참고로 여기서 콜백으로 넘기는 함수 자체를 IIFE로 만들면 되지 않나 싶지만,그렇게 하면 원하는대로 0-9까지 출력은 되지만 함수 내부가 즉시 실행되어 버리므로 setTimeout()의 0.1초 딜레이가 작동하지 않게 된다. private 변수 생성하기(캡슐화)일반적으로 Javascript에서 객체지향 프로그래밍을 말한다면 Prototype을 통해 객체를 다루는 것을 말한다.Prototype을 통한 객체를 만들 때의 주요한 문제 중 하나는 Private variables에 대한 접근 권한 문제이다. 예제 코드를 보자. 1234567891011121314151617function Hello(name) &#123; this._name = name;&#125;Hello.prototype.say = function() &#123; console.log('Hello, ' + this._name);&#125;var hello1 = new Hello('피카츄');var hello2 = new Hello('이상해씨');var hello3 = new Hello('잠만보');hello1.say(); // 'Hello, 피카츄'hello2.say(); // 'Hello, 이상해씨'hello3.say(); // 'Hello, 잠만보'hello1._name = 'anonymous';hello1.say(); // 'Hello, anonymous' 위에서 Hello()로 생성된 객체들은 모두 _name이라는 변수를 가지게 된다.변수명 앞에 underscore(_)를 포함했기 때문에 일반적인 Javascript 네이밍 컨벤션을 생각해 봤을때이 변수는 Private variable으로 쓰고싶다는 의도를 알 수 있다.하지만 실제로는 여전히 외부에서도 쉽게 접근가능한 변수일 뿐이다. 이 경우에 클로저를 사용하여 외부에서 변수에 직접 접근하는 것을 제한할 수 있다. 1234567891011121314function hello(name) &#123; var _name = name; return function() &#123; console.log('Hello, ' + _name); &#125;;&#125;var hello1 = hello('피카츄');var hello2 = hello('이상해씨');var hello3 = hello('잠만보');hello1(); // 'Hello, 피카츄'hello2(); // 'Hello, 이상해씨'hello3(); // 'Hello, 잠만보' 특별히 인터페이스를 제공하는 것이 아니라면, 여기서는 외부에서 _name에 접근할 방법이 전혀 없다.이렇게 은닉화도 생각보다 쉽게 해결할 수 있다. 클로저의 성능클로저는 각자의 환경을 가진다. 이 환경을 기억하기 위해서는 당연히 메모리가 소모될 것이다.클로저를 생성해놓고 참조를 제거하지 않는 것은 C++에서 동적할당으로 객체를 생성해놓고 delete를 사용하지 않는 것과 비슷하다.클로저를 통해 내부 변수를 참조하는 동안에는 내부 변수가 차지하는 메모리를 GC가 회수하지 않는다.따라서 클로저 사용이 끝나면 참조를 제거하는 것이 좋다. 12345678910111213141516171819function hello(name) &#123; var _name = name; return function() &#123; console.log('Hello, ' + _name); &#125;;&#125;var hello1 = hello('피카츄');var hello2 = hello('이상해씨');var hello3 = hello('잠만보');hello1(); // 'Hello, 피카츄'hello2(); // 'Hello, 이상해씨'hello3(); // 'Hello, 잠만보'// 여기서 메모리를 release 시키기 클로저의 참조를 제거해야 한다.hello1 = null;hello2 = null;hello3 = null; 이처럼 메모리 관리에 있어서 약점이 있지만 추가로 스코프 체인을 검색하는 시간과 새로운 스코프를 생성하는데 드는 비용도 감안하지 않을 수 없다.이 부분에 대해서는 Javascript 스코프를 주제로 하는 별도의 글에서 다룰 것이다. 참고 문서 Javascript 클로저(Closure) 자바스크립트 스코프와 클로저","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"closure","slug":"closure","permalink":"https://kkapkkapchu.github.io/blog/tags/closure/"}]},{"title":"[Javascript] new Date('YYYY-MM-DD HH:MM') is InvalidDate in IE","slug":"javascript_invaliddate_in_IE","date":"2018-06-15T08:44:00.000Z","updated":"2018-12-07T08:23:35.796Z","comments":true,"path":"2018/06/15/javascript_invaliddate_in_IE/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/06/15/javascript_invaliddate_in_IE/","excerpt":"","text":"new Date()으로 날짜 생성하기자바스크립트 자체내에서 new Date() 함수를 지원한다.파라미터를 안 주게 되면 현재 날짜로 생성되고,()안에 컴마(,)/대시(-)/슬래시(/) 등 여러가지 방식으로 파라미터를 줄 수 있다. 하지만 이 중에 제목처럼 new Date(&#39;YYYY-MM-DD HH:MM&#39;) 을 하게 되면 크롬에서는 잘 나오나,IE에서는 InvalidDate으로 나온다.이 문제를 해결하기 위해서는 연도와 시간 사이에 빈칸대신 T를 넣으면 된다. 12345// for Chromenew Date('2018-06-15 17:44') // FRI JUN 15 2018 17:44:00 GMT+0900 (KST) // for Chrome, IEnew Date('2018-06-15T17:44') // FRI JUN 15 2018 17:44:00 GMT+0900 (KST)","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"IE","slug":"IE","permalink":"https://kkapkkapchu.github.io/blog/tags/IE/"},{"name":"dateTime","slug":"dateTime","permalink":"https://kkapkkapchu.github.io/blog/tags/dateTime/"}]},{"title":"[React] 리액트에서 뒤로가기 시 브라우저 확인 창 띄우기","slug":"react_backbutton_browser_alert","date":"2018-06-15T08:08:00.000Z","updated":"2018-12-13T05:06:11.945Z","comments":true,"path":"2018/06/15/react_backbutton_browser_alert/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/06/15/react_backbutton_browser_alert/","excerpt":"","text":"React에서 라우터 이동 시 발생하는 이벤트페이지를 벗어날 때(새로고침/닫기/뒤로가기)를 잡고 싶을 때가 있을 것이다.대부분 블로그에서는 onBeforeUnload 이벤트에 대해서만 설명을 하고 있다. 하지만 onBeforeUnload 이벤트는 React에서 뒤로가기 시에 호출되지 않는다!!!React에서 뒤로가기 이벤트를 잡고 싶을 때에는 setRouteLeaveHook를 사용하면 된다.setRouteLeaveHook 는 리액트에서 라우터가 바뀔 때 호출된다. setRouteLeaveHook 이벤트를 사용하기 위해서는 withRouter 로 컴포넌트를 감싸줘야 한다.그리고 router 는 기본으로 props 로 넘어오지만 route 는 현재 컴포넌트가 하위 레벨이라면 부모 컴포넌트로부터 전달받아야 한다. 12345678910111213141516171819202122232425import &#123; withRouter &#125; from 'react-router';class WriteMail extends Component &#123; componentDidMount() &#123; // 라우터 이동시 this.props.router.setRouteLeaveHook(this.props.route, () =&gt; &#123; // 변경사항이 없다면 그냥 브라우저를 벗어남 if (!this.isChange()) return; // 뒤로가기 확인 창 if (!window.confirm(\"이 페이지를 벗어나면 마지막 저장 후 수정된 내용은 저장되지 않습니다.\")) &#123; // 취소 버튼 클릭 window.location.href = '/writeMail'; // window.history.back(); // React 에서 주의해서 쓸 것!! return false; &#125; else &#123; // 확인 버튼 클릭 return true; &#125; &#125;) &#125;&#125;export default withRouter(WriteMail, &#123; withRef: true &#125;); 브라우저를 벗어날지 말지 확인하는 창을 띄운 후 사용자가 취소 버튼을 클릭했다면, 이전 주소로 바꿔주어야 한다.이 때 window.history.back() 는 React 에서 매우 조심해야 한다!!이전 포스팅에서처럼 리액트는 SPA이기 때문에 url 을 바꾼다해도 그게 제대로 history에 들어가지 않는거 같다.그래서 window.location.href로 아예 이전 url 로 바꿔준 것이다. Redux를 사용한다면…위의 WriteMail 컴포넌트의 상위 컴포넌트에서 하위 컴포넌트에 정의된 함수를 사용하려면this.refs.refWriteMail.getWrappedInstance().함수이름() 를 사용했을 것이다.하지만 withRouter로 한번 더 감쌌기 때문에this.refs.refWriteMail.getWrappedInstance().refs.wrappedInstance.함수이름()으로 사용해야 한다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"React","slug":"Web/React","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/React/"}],"tags":[{"name":"onBeforeUnload","slug":"onBeforeUnload","permalink":"https://kkapkkapchu.github.io/blog/tags/onBeforeUnload/"},{"name":"setRouteLeaveHook","slug":"setRouteLeaveHook","permalink":"https://kkapkkapchu.github.io/blog/tags/setRouteLeaveHook/"}]},{"title":"[Javascript] 페이지 벗어날 때(새로고침/닫기/뒤로가기) 브라우저 확인 창 띄우기","slug":"javascript_onbeforeunload","date":"2018-06-15T07:51:00.000Z","updated":"2018-12-07T08:23:35.800Z","comments":true,"path":"2018/06/15/javascript_onbeforeunload/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/06/15/javascript_onbeforeunload/","excerpt":"","text":"페이지 벗어날 때(새로고침/닫기/뒤로가기) 발생하는 이벤트메일을 작성 중일 때 화면을 벗어나려고 하면 브라우저 자체 확인 창이 뜬다.화면을 벗어날 때 onBeforeUnload 이벤트가 호출되므로 여기서 작업을 하면 된다. 1234567891011121314onBeforeUnload = (event) =&gt; &#123; // 변경사항이 없다면 그냥 브라우저를 벗어남 if (!this.isChange()) return; event.returnValue = \"변경사항이 저장되지 않을 수 있습니다.\";&#125;componentDidMount() &#123; window.addEventListener(\"beforeunload\", this.onBeforeUnload); // 페이지 새로고침, 닫기&#125;componentWillUnmount() &#123; window.removeEventListener(\"beforeunload\", this.onBeforeUnload);&#125; 하지만 여기서 중요한 거!! 나는 리액트를 사용하므로 onBeforeUnload 이벤트가 페이지 닫기나 새로고침시에는 잘 호출되지만뒤로가기를 할 때에는 호출이 안된다. 아마도 라우터 때문인듯하다..onBeforeUnload 이벤트는 현재 window 를 벗어날 때 호출되는 거 같은데,리액트는 SPA(Single Page App)이기 때문에 url이 바뀌더라도 dom이 바뀌지 window 가 바뀌지 않는다. 리액트 컴포넌트에서 뒤로가기 이벤트를 잡으려면 setRouteLeaveHook 를 이용하는 방법이 있다.이거에 대해서는 다음 포스팅을 쓰도록 하겠다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"onBeforeUnload","slug":"onBeforeUnload","permalink":"https://kkapkkapchu.github.io/blog/tags/onBeforeUnload/"}]},{"title":"[Javascript] window.open()에 헤더 추가하기","slug":"javascript_add_header_to_window_open","date":"2017-09-05T05:24:01.000Z","updated":"2018-12-07T08:23:35.785Z","comments":true,"path":"2017/09/05/javascript_add_header_to_window_open/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/09/05/javascript_add_header_to_window_open/","excerpt":"","text":"window.open(url); 을 하면 새 창이 열린다.새 창을 열 때 헤더를 추가하려면 아래와 같이 하면 된다. 1234567891011121314let xhttp = new XMLHttpRequest();xhttp.open(\"GET\", url, true);xhttp.setRequestHeader(\"Content-type\", \"application/json\"]);xhttp.responseType = \"blob\";xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; // Typical action to be performed when the document is ready: window.open(URL.createObjectURL(xhttp.response)); &#125;&#125;;xhttp.send();","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"window.open","slug":"window-open","permalink":"https://kkapkkapchu.github.io/blog/tags/window-open/"},{"name":"add_header","slug":"add-header","permalink":"https://kkapkkapchu.github.io/blog/tags/add-header/"}]},{"title":"[Javascript] Object 의 key/value 값 가져오기","slug":"javascript_get_object_key_value","date":"2017-09-05T05:24:01.000Z","updated":"2018-12-07T08:23:35.794Z","comments":true,"path":"2017/09/05/javascript_get_object_key_value/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/09/05/javascript_get_object_key_value/","excerpt":"","text":"Object 의 key 값 가져오기123456let requestHeaderObject = &#123; key1: value1, key2: value2,&#125;;console.log(Object.keys(requestHeaderObject)); // [\"key1\", \"key2\"] Object.keys 안에 key 값을 가져올 객체를 넣으면 객체의 key 값이 배열로 떨어진다. value 를 가져올 때는 객체의 key 배열을 돌면서 value 를 가져오면 된다. Object 의 value 값 가져오기1234567891011let requestHeaderObject = &#123; key1: value1, key2: value2,&#125;;Object.keys(requestHeaderObject).map((value) =&gt; &#123; console.log(value, requestHeaderObject[value]);&#125;);// key1 value1// key2 value2","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"object","slug":"object","permalink":"https://kkapkkapchu.github.io/blog/tags/object/"},{"name":"key/value","slug":"key-value","permalink":"https://kkapkkapchu.github.io/blog/tags/key-value/"}]},{"title":"[Javascript] input 에서 마우스 커서 위치 얻어오기 및 변경하기","slug":"javascript_get_set_input_cursor","date":"2017-08-28T07:22:44.000Z","updated":"2018-12-07T08:23:35.795Z","comments":true,"path":"2017/08/28/javascript_get_set_input_cursor/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/28/javascript_get_set_input_cursor/","excerpt":"","text":"input 요소의 마우스 커서 위치 얻어오기1234567891011121314151617181920/** * 커서의 위치를 반환합니다. */getCaretPosition = () =&gt; &#123; let targetElement = this.refs.input; if (document.selection) &#123; // IE &lt; 9 targetElement.focus(); let range = document.selection.createRange(); let rangeLength = range.text.length; range.moveStart('character', -targetElement.value.length); let start = range.text.length - rangeLength; return &#123;'start': start, 'end': start + rangeLength&#125;; &#125; else if (targetElement.selectionStart || targetElement.selectionStart == '0') &#123; // IE &gt;= 9 and Other Browsers return &#123;'start': targetElement.selectionStart, 'end': targetElement.selectionEnd&#125;; &#125; else &#123; return &#123;'start': 0, 'end': 0&#125;; &#125;&#125;; input 요소의 마우스 커서 위치 변경하기1234567891011121314151617/** * 커서의 위치를 지정합니다. */setCaretPosition = (start, end) =&gt; &#123; let targetElement = this.refs.input; if (targetElement.setSelectionRange) &#123; // IE &gt;= 9 and Other Browsers targetElement.focus(); targetElement.setSelectionRange(start, end); &#125; else if (targetElement.createTextRange) &#123; // IE &lt; 9 let range = targetElement.createTextRange(); range.collapse(true); range.moveEnd('character', end); range.moveStart('character', start); range.select(); &#125;&#125;;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"mouse_cursor_get","slug":"mouse-cursor-get","permalink":"https://kkapkkapchu.github.io/blog/tags/mouse-cursor-get/"},{"name":"mouse_cursor_set","slug":"mouse-cursor-set","permalink":"https://kkapkkapchu.github.io/blog/tags/mouse-cursor-set/"},{"name":"caret_position","slug":"caret-position","permalink":"https://kkapkkapchu.github.io/blog/tags/caret-position/"}]},{"title":"[Javascript] 마우스 우클릭 이벤트와 좌클릭 이벤트 구분하기","slug":"javascript_mouse_right_click","date":"2017-08-28T07:22:44.000Z","updated":"2018-12-07T08:23:35.799Z","comments":true,"path":"2017/08/28/javascript_mouse_right_click/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/28/javascript_mouse_right_click/","excerpt":"","text":"리액트에서 onTouchTap 을 사용했을 때 마우스 우클릭을 하면 처음에는 이벤트 호출이 안되는데,두 번째 우클릭부터는 onTouchTap 이벤트가 호출된다.(onClick 은 무조건 마우스 좌클릭만 호출된다.) 스크립트에서 마우스 우클릭과 좌클릭을 구분해야 할 때는 onClick 이나 onTouchTap 이 아닌 onMouseDown 이나 onMouseUp 이벤트를 사용해야 한다. 123456789handleMouseUp = (event) =&gt; &#123; console.log(event.button) // 1: left, 2: right&#125;render() &#123; return ( &lt;button onMouseUp=&#123;this.handleMouseUp&#125;&gt;마우스 클릭이벤트 구분&lt;/button&gt; )&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"mouse_click_event","slug":"mouse-click-event","permalink":"https://kkapkkapchu.github.io/blog/tags/mouse-click-event/"},{"name":"onTouchTap","slug":"onTouchTap","permalink":"https://kkapkkapchu.github.io/blog/tags/onTouchTap/"}]},{"title":"[React] propTypes 에 array 타입으로 지정할 때 array 안에 들어가는 값에 대한 타입 지정하기","slug":"react_proptypes_arrayof","date":"2017-08-25T04:22:54.000Z","updated":"2018-12-13T05:06:16.193Z","comments":true,"path":"2017/08/25/react_proptypes_arrayof/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/25/react_proptypes_arrayof/","excerpt":"","text":"React 에서 속성의 타입을 정의할 때 propTypes를 사용하면 편하다.속성의 타입이 array 라면 배열 안의 값에 대한 타입도 arrayOf()로 지정할 수 있다. 아래 예시는 배열 안의 값의 타입을 숫자로 정의한 것이다.12// An array of a certain typeoptionalArrayOf: PropTypes.arrayOf(PropTypes.number), 배열 안의 값의 타입을 PropTypes.number 로 지정했기 때문에 숫자말고 다른 타입이 들어오면 에러가 난다.부모 컴포넌트에서 넘어오는 속성 값은 숫자로 된 배열이어야 한다. (ex) optionalArrayOf=[1, 2, 3]) 이외에도 아래와 같이 많은 타입을 정의할 수 있도록 제공된다. 제공되는 PropTypes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // You can declare that a prop is a specific JS primitive. By default, these // are all optional. optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // Anything that can be rendered: numbers, strings, elements or an array // (or fragment) containing these types. optionalNode: PropTypes.node, // A React element. optionalElement: PropTypes.element, // You can also declare that a prop is an instance of a class. This uses // JS's instanceof operator. optionalMessage: PropTypes.instanceOf(Message), // You can ensure that your prop is limited to specific values by treating // it as an enum. optionalEnum: PropTypes.oneOf(['News', 'Photos']), // An object that could be one of many types optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // An array of a certain type optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // An object with property values of a certain type optionalObjectOf: PropTypes.objectOf(PropTypes.number), // An object taking on a particular shape optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // You can chain any of the above with `isRequired` to make sure a warning // is shown if the prop isn't provided. requiredFunc: PropTypes.func.isRequired, // A value of any data type requiredAny: PropTypes.any.isRequired, // You can also specify a custom validator. It should return an Error // object if the validation fails. Don't `console.warn` or throw, as this // won't work inside `oneOfType`. customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // You can also supply a custom validator to `arrayOf` and `objectOf`. // It should return an Error object if the validation fails. The validator // will be called for each key in the array or object. The first two // arguments of the validator are the array or object itself, and the // current item's key. customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; 참고사이트: https://facebook.github.io/react/docs/typechecking-with-proptypes.html","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"React","slug":"Web/React","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/React/"}],"tags":[{"name":"propTypes","slug":"propTypes","permalink":"https://kkapkkapchu.github.io/blog/tags/propTypes/"},{"name":"array","slug":"array","permalink":"https://kkapkkapchu.github.io/blog/tags/array/"}]},{"title":"[Javascript] keycode 라이브러리 사용시 키보드 오른쪽 keypad 숫자 가져오기","slug":"javascript_library_keycode_keypad","date":"2017-08-17T02:01:12.000Z","updated":"2018-12-10T05:29:07.236Z","comments":true,"path":"2017/08/17/javascript_library_keycode_keypad/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/17/javascript_library_keycode_keypad/","excerpt":"","text":"keycode 라이브러리를 사용해서 값을 가져오고 숫자만 뽑아내기 위해서 정규식을 쓰는 경우가 있다.이때 조심해야 하는 경우가 있는데 바로 키보드 오른쪽의 keypad 로 입력했을 때이다. IE에서는 keypad 로 숫자 입력시 keycode 라이브러리로 값을 가져오면 “numpad 숫자“ 로 찍힌다.그래서 숫자 정규식을 쓰려면 숫자만 뽑아내야 한다. 123456789import keycode from 'keycode'// 맨 뒤의 숫자만 가져오기// console.log(keycode(event)); // IE: \"numpad 숫자\", Others: \"숫자\"let keycodeStr = keycode(event).slice(-1);// 숫자만인지 체크하는 정규식const regNumber = /^[0-9]*$/;if ( !regNumber.test(keycodeStr) ) return;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"},{"name":"Library","slug":"Web/Javascript/Library","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/Library/"}],"tags":[{"name":"IE","slug":"IE","permalink":"https://kkapkkapchu.github.io/blog/tags/IE/"},{"name":"keycode","slug":"keycode","permalink":"https://kkapkkapchu.github.io/blog/tags/keycode/"}]},{"title":"[Javascript] HTML 요소 동적으로 생성하고 속성(Attribute) 추가하기","slug":"javascript_create_html_element_dynamically","date":"2017-08-13T07:18:27.000Z","updated":"2018-12-07T08:23:35.793Z","comments":true,"path":"2017/08/13/javascript_create_html_element_dynamically/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/13/javascript_create_html_element_dynamically/","excerpt":"","text":"요소를 동적으로 생성하고 원하는 위치에 붙이기12345678// 요소 동적 생성let div = document.createElement(\"div\");// 원하는 위치에 붙인다document.body.appendChild(div);// React 에서는 요소를 붙이고 싶은 위치를 ref 로 잡아서도 가능 this.refs.test.appendChild(div); 동적으로 생성한 요소에 속성(Attribute) 추가하기1234567891011// 요소 동적 생성let div = document.createElement(\"div\");// 속성을 추가한다div.setAttribute(\"style\", \"width: 100%; height: 100%;\")// 원하는 위치에 붙인다document.body.appendChild(div);// React 에서는 요소를 붙이고 싶은 위치를 ref 로 잡아서도 가능 this.refs.test.appendChild(div); div.setAttribute(“style”, “width: 100%; height: 100%;”) 에서 첫 번째 인자가 추가할 속성의 이름이고,두 번째 인자가 추가할 속성의 값이다. 동적으로 생성한 요소에 이벤트 속성 추가하기12345678// 요소 동적 생성let a = document.createElement(\"a\");if (a.addEventListener) &#123; a.addEventListener('click', handler, false); &#125; else if (el.attachEvent) &#123; a.attachEvent('onclick', handler);&#125; onclick, onblur 와 같은 이벤트 속성을 추가하고 싶을 때는 setAttribute 가 아닌 addEventListener 로 하면 된다. 동적으로 생성한 요소 삭제하기12345&lt;ul id=\"myList\"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 위의 예제처럼 ul, li 태그가 생성되었다고 할 때, li 태그를 지우고 싶으면 아래 예제처럼 하면 된다.12345678// 삭제할 요소의 상위(부모) 요소let myNode = document.getElementById(\"myList\");// 원하는 자식 요소만 지우기myNode.removeChild(myNode.childNodes[0]);// 자식 요소들 한번에 지우기myNode.innerHTML = '';","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Javascript/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://kkapkkapchu.github.io/blog/tags/HTML/"}]},{"title":"[CSS] CSS에서 calc 함수 중첩해서 쓰기","slug":"css_calc_in_calc_for_ie","date":"2017-08-03T11:31:27.000Z","updated":"2018-12-07T08:23:35.778Z","comments":true,"path":"2017/08/03/css_calc_in_calc_for_ie/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/03/css_calc_in_calc_for_ie/","excerpt":"","text":"Calc() function inside another calc() in CSS123456789// for Chrome, IE 9div&#123; width: calc(100% - (1% + 30px)); /* calc(1% + 30px) is nested inside calc() */&#125;// for Chromediv p&#123; width: calc(100% - calc(1% + 30px));&#125; 크롬은 둘 다 지원하지만 IE는 첫 번째만 지원한다.IE에서 calc 함수를 중첩으로 사용하려면 맨 앞에 calc로 한번만 감싸야한다. 이를 위해서 안의 중첩된 calc 글자를 없애주는 라이브러리(reduce-css-calc)도 있는거 같은데,이 라이브러리 안에서 쓰이는 “fs” 라이브러리가 없어진듯 하다… 그래서 못씀.. 아무튼 해결법은 calc를 한번만 사용하도록 식을 바꾸든지, 중첩된 calc 를 계산해서 숫자로 바꿔주는 라이브러리를 만들든지 찾든지 해야한다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"CSS","slug":"Web/CSS","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/CSS/"}],"tags":[{"name":"IE","slug":"IE","permalink":"https://kkapkkapchu.github.io/blog/tags/IE/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-24T06:31:27.000Z","updated":"2018-12-07T08:23:35.779Z","comments":true,"path":"2017/07/24/hello-world/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/07/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Generate And Deploy1$ hexo g -d","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Hexo/"}],"tags":[]}]}