{"meta":{"title":"깝깝츄의 개발일기","subtitle":"코딩왕","description":null,"author":"깝깝츄","url":"https://kkapkkapchu.github.io/blog"},"pages":[{"title":"About","date":"2017-08-02T06:24:16.000Z","updated":"2017-08-01T05:15:09.000Z","comments":true,"path":"about/index.html","permalink":"https://kkapkkapchu.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-08-02T06:23:25.000Z","updated":"2017-08-01T05:15:09.000Z","comments":true,"path":"categories/index.html","permalink":"https://kkapkkapchu.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-08-02T06:24:16.000Z","updated":"2017-08-01T05:15:09.000Z","comments":true,"path":"tags/index.html","permalink":"https://kkapkkapchu.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"자바스크립트 클로저(Closure)에 대해","slug":"20180707","date":"2018-07-07T14:02:00.000Z","updated":"2018-07-08T04:57:29.000Z","comments":true,"path":"2018/07/07/20180707/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/07/07/20180707/","excerpt":"","text":"클로저란 무엇인가함수 내부에 함수를 작성할 때마다 이미 클로저를 생성한 것이다.내부에 작성한 함수가 바로 클로저라닛!! 여태껏 클로저가 뭔지도 모르고 사용했다.. 12345678function outerFunction () &#123; const outer = 'I see the outer variable!' return function innerFunction() &#123; console.log(outer) &#125;&#125;outerFunction()() // I see the outer variable! 클로저를 왜 쓸까클로저는 외부함수의 변수에 접근이 가능하다. (자바스크립의 스코프를 이해한다면 당연한 것)때문에 일반적으로 두 가지의 목적이 있다. 사이드 이펙트(side effects) 제어하기 private 변수 생성하기(캡슐화) 사이드 이펙트(side effects) 제어하기함수에서 값을 반환할 때를 제외하고 무언가를 행할 때 사이드 이펙트(side effects)가 발생한다.여러 가지 것들이 사이드 이펙트가 될 수 있는데, 예를 들어 Ajax 요청이나 timeout을 생성할 때,그리고 심지어 console.log를 선언하는 것도 사이드 이펙트이다. 보통 Ajax나 timeout과 같이 코드 흐름을 방해하는 것들이 신경 쓰일 때,클로저를 활용하여 사이드 이펙트를 제어한다. 123456var i;for (i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100);&#125; 간단하게 0-9까지의 정수를 출력하는 코드이지만 실제로 돌려보면 엉뚱하게도 10만 열 번 출력되는 걸 볼 수 있다. 왜일까?먼저 setTimeout()에 인자로 넘긴 익명함수는 모두 0.1초 뒤에 호출될 것이다.그 0.1초 동안에 이미 반복문이 모두 순회되면서 i값은 이미 10이 된 상태.그 때 익명함수가 호출되면서 이미 10이 되어버린 i를 참조하는 것이다. 이 경우에도 클로저를 사용하면 원하는 대로 동작하도록 만들 수 있다. 12345678var i;for (i = 0; i &lt; 10; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 100); &#125;)(i);&#125; 중간에 즉시 실행 함수(IIFE)를 덧붙여 setTimeout()에 걸린 익명함수를 클로저로 만들었다.클로저는 만들어진 환경을 기억한다. 이 코드에서 i는 IIFE내에 j라는 형태로 주입되고, 클로저에 의해 각기 다른 환경속에 포함된다.반복문은 10회 반복되므로 10개의 환경이 생길 것이고, 10개의 서로 다른 환경에 10개의 서로 다른 j가 생긴다. 위의 예제에서는 IIFE를 통해서 클로저마다 환경이 생긴다.하지만 인자로 i를 넘기지 않는다면 당연히 클로저가 참조하는 IIFE의 함수 스코프에서도 i값이 없으므로 생성 당시의 외부 스코프인 글로벌을 탐색하게 되고 결국 모두 같은 i를 참조하게 된다.반면에, 인자로 i를 넘기게 되면 IIFE로 만든 10개의 스코프에 모두 i라는 변수가 다른 값으로 생기므로 정상적으로 동작할 수 있는 것이다. 참고로 여기서 콜백으로 넘기는 함수 자체를 IIFE로 만들면 되지 않나 싶지만,그렇게 하면 원하는대로 0-9까지 출력은 되지만 함수 내부가 즉시 실행되어 버리므로 setTimeout()의 0.1초 딜레이가 작동하지 않게 된다. private 변수 생성하기(캡슐화)일반적으로 JavaScript에서 객체지향 프로그래밍을 말한다면 Prototype을 통해 객체를 다루는 것을 말한다.Prototype을 통한 객체를 만들 때의 주요한 문제 중 하나는 Private variables에 대한 접근 권한 문제이다. 예제 코드를 보자. 1234567891011121314151617function Hello(name) &#123; this._name = name;&#125;Hello.prototype.say = function() &#123; console.log('Hello, ' + this._name);&#125;var hello1 = new Hello('피카츄');var hello2 = new Hello('이상해씨');var hello3 = new Hello('잠만보');hello1.say(); // 'Hello, 피카츄'hello2.say(); // 'Hello, 이상해씨'hello3.say(); // 'Hello, 잠만보'hello1._name = 'anonymous';hello1.say(); // 'Hello, anonymous' 위에서 Hello()로 생성된 객체들은 모두 _name이라는 변수를 가지게 된다.변수명 앞에 underscore(_)를 포함했기 때문에 일반적인 JavaScript 네이밍 컨벤션을 생각해 봤을때이 변수는 Private variable으로 쓰고싶다는 의도를 알 수 있다.하지만 실제로는 여전히 외부에서도 쉽게 접근가능한 변수일 뿐이다. 이 경우에 클로저를 사용하여 외부에서 변수에 직접 접근하는 것을 제한할 수 있다. 1234567891011121314function hello(name) &#123; var _name = name; return function() &#123; console.log('Hello, ' + _name); &#125;;&#125;var hello1 = hello('피카츄');var hello2 = hello('이상해씨');var hello3 = hello('잠만보');hello1(); // 'Hello, 피카츄'hello2(); // 'Hello, 이상해씨'hello3(); // 'Hello, 잠만보' 특별히 인터페이스를 제공하는 것이 아니라면, 여기서는 외부에서 _name에 접근할 방법이 전혀 없다.이렇게 은닉화도 생각보다 쉽게 해결할 수 있다. 클로저의 성능클로저는 각자의 환경을 가진다. 이 환경을 기억하기 위해서는 당연히 메모리가 소모될 것이다.클로저를 생성해놓고 참조를 제거하지 않는 것은 C++에서 동적할당으로 객체를 생성해놓고 delete를 사용하지 않는 것과 비슷하다.클로저를 통해 내부 변수를 참조하는 동안에는 내부 변수가 차지하는 메모리를 GC가 회수하지 않는다.따라서 클로저 사용이 끝나면 참조를 제거하는 것이 좋다. 12345678910111213141516171819function hello(name) &#123; var _name = name; return function() &#123; console.log('Hello, ' + _name); &#125;;&#125;var hello1 = hello('피카츄');var hello2 = hello('이상해씨');var hello3 = hello('잠만보');hello1(); // 'Hello, 피카츄'hello2(); // 'Hello, 이상해씨'hello3(); // 'Hello, 잠만보'// 여기서 메모리를 release 시키기 클로저의 참조를 제거해야 한다.hello1 = null;hello2 = null;hello3 = null; 이처럼 메모리 관리에 있어서 약점이 있지만 추가로 스코프 체인을 검색하는 시간과 새로운 스코프를 생성하는데 드는 비용도 감안하지 않을 수 없다.이 부분에 대해서는 JavaScript 스코프를 주제로 하는 별도의 글에서 다룰 것이다. 참고 문서 JavaScript 클로저(Closure) 자바스크립트 스코프와 클로저","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"}],"tags":[{"name":"closure","slug":"closure","permalink":"https://kkapkkapchu.github.io/blog/tags/closure/"}]},{"title":"new Date('YYYY-MM-DD HH:MM') is InvalidDate in IE","slug":"20180615_3","date":"2018-06-15T08:44:00.000Z","updated":"2018-06-15T08:51:47.000Z","comments":true,"path":"2018/06/15/20180615_3/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/06/15/20180615_3/","excerpt":"","text":"new Date()으로 날짜 생성하기자바스크립트 자체내에서 new Date() 함수를 지원한다.파라미터를 안 주게 되면 현재 날짜로 생성되고,()안에 컴마(,)/대시(-)/슬래시(/) 등 여러가지 방식으로 파라미터를 줄 수 있다. 하지만 이 중에 제목처럼 new Date(&#39;YYYY-MM-DD HH:MM&#39;) 을 하게 되면 크롬에서는 잘 나오나,IE에서는 InvalidDate으로 나온다.이 문제를 해결하기 위해서는 연도와 시간 사이에 빈칸대신 T를 넣으면 된다. 12345// for Chromenew Date('2018-06-15 17:44') // FRI JUN 15 2018 17:44:00 GMT+0900 (KST) // for Chrome, IEnew Date('2018-06-15T17:44') // FRI JUN 15 2018 17:44:00 GMT+0900 (KST)","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"}],"tags":[{"name":"IE","slug":"IE","permalink":"https://kkapkkapchu.github.io/blog/tags/IE/"},{"name":"dateTime","slug":"dateTime","permalink":"https://kkapkkapchu.github.io/blog/tags/dateTime/"}]},{"title":"리액트에서 뒤로가기 시 브라우저 확인 창 띄우기","slug":"20180615_2","date":"2018-06-15T08:08:00.000Z","updated":"2018-06-18T00:06:34.000Z","comments":true,"path":"2018/06/15/20180615_2/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/06/15/20180615_2/","excerpt":"","text":"React에서 라우터 이동 시 발생하는 이벤트페이지를 벗어날 때(새로고침/닫기/뒤로가기)를 잡고 싶을 때가 있을 것이다.대부분 블로그에서는 onBeforeUnload 이벤트에 대해서만 설명을 하고 있다. 하지만 onBeforeUnload 이벤트는 React에서 뒤로가기 시에 호출되지 않는다!!!React에서 뒤로가기 이벤트를 잡고 싶을 때에는 setRouteLeaveHook를 사용하면 된다.setRouteLeaveHook 는 리액트에서 라우터가 바뀔 때 호출된다. setRouteLeaveHook 이벤트를 사용하기 위해서는 withRouter 로 컴포넌트를 감싸줘야 한다.그리고 router 는 기본으로 props 로 넘어오지만 route 는 현재 컴포넌트가 하위 레벨이라면 부모 컴포넌트로부터 전달받아야 한다. 12345678910111213141516171819202122232425import &#123; withRouter &#125; from 'react-router';class WriteMail extends Component &#123; componentDidMount() &#123; // 라우터 이동시 this.props.router.setRouteLeaveHook(this.props.route, () =&gt; &#123; // 변경사항이 없다면 그냥 브라우저를 벗어남 if (!this.isChange()) return; // 뒤로가기 확인 창 if (!window.confirm(\"이 페이지를 벗어나면 마지막 저장 후 수정된 내용은 저장되지 않습니다.\")) &#123; // 취소 버튼 클릭 window.location.href = '/writeMail'; // window.history.back(); // React 에서 주의해서 쓸 것!! return false; &#125; else &#123; // 확인 버튼 클릭 return true; &#125; &#125;) &#125;&#125;export default withRouter(WriteMail, &#123; withRef: true &#125;); 브라우저를 벗어날지 말지 확인하는 창을 띄운 후 사용자가 취소 버튼을 클릭했다면, 이전 주소로 바꿔주어야 한다.이 때 window.history.back() 는 React 에서 매우 조심해야 한다!!이전 포스팅에서처럼 리액트는 SPA이기 때문에 url 을 바꾼다해도 그게 제대로 history에 들어가지 않는거 같다.그래서 window.location.href로 아예 이전 url 로 바꿔준 것이다. Redux를 사용한다면…위의 WriteMail 컴포넌트의 상위 컴포넌트에서 하위 컴포넌트에 정의된 함수를 사용하려면this.refs.refWriteMail.getWrappedInstance().함수이름() 를 사용했을 것이다.하지만 withRouter로 한번 더 감쌌기 때문에this.refs.refWriteMail.getWrappedInstance().refs.wrappedInstance.함수이름()으로 사용해야 한다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"},{"name":"React","slug":"Web/JavaScript/React","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/React/"}],"tags":[{"name":"onBeforeUnload","slug":"onBeforeUnload","permalink":"https://kkapkkapchu.github.io/blog/tags/onBeforeUnload/"},{"name":"setRouteLeaveHook","slug":"setRouteLeaveHook","permalink":"https://kkapkkapchu.github.io/blog/tags/setRouteLeaveHook/"}]},{"title":"페이지 벗어날 때(새로고침/닫기/뒤로가기) 브라우저 확인 창 띄우기","slug":"20180615","date":"2018-06-15T07:51:00.000Z","updated":"2018-06-18T00:08:04.000Z","comments":true,"path":"2018/06/15/20180615/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2018/06/15/20180615/","excerpt":"","text":"페이지 벗어날 때(새로고침/닫기/뒤로가기) 발생하는 이벤트메일을 작성 중일 때 화면을 벗어나려고 하면 브라우저 자체 확인 창이 뜬다.화면을 벗어날 때 onBeforeUnload 이벤트가 호출되므로 여기서 작업을 하면 된다. 1234567891011121314onBeforeUnload = (event) =&gt; &#123; // 변경사항이 없다면 그냥 브라우저를 벗어남 if (!this.isChange()) return; event.returnValue = \"변경사항이 저장되지 않을 수 있습니다.\";&#125;componentDidMount() &#123; window.addEventListener(\"beforeunload\", this.onBeforeUnload); // 페이지 새로고침, 닫기&#125;componentWillUnmount() &#123; window.removeEventListener(\"beforeunload\", this.onBeforeUnload);&#125; 하지만 여기서 중요한 거!! 나는 리액트를 사용하므로 onBeforeUnload 이벤트가 페이지 닫기나 새로고침시에는 잘 호출되지만뒤로가기를 할 때에는 호출이 안된다. 아마도 라우터 때문인듯하다..onBeforeUnload 이벤트는 현재 window 를 벗어날 때 호출되는 거 같은데,리액트는 SPA(Single Page App)이기 때문에 url이 바뀌더라도 dom이 바뀌지 window 가 바뀌지 않는다. 리액트 컴포넌트에서 뒤로가기 이벤트를 잡으려면 setRouteLeaveHook 를 이용하는 방법이 있다.이거에 대해서는 다음 포스팅을 쓰도록 하겠다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"}],"tags":[{"name":"onBeforeUnload","slug":"onBeforeUnload","permalink":"https://kkapkkapchu.github.io/blog/tags/onBeforeUnload/"}]},{"title":"window.open()에 헤더 추가하기","slug":"20170905-2","date":"2017-09-05T05:24:01.000Z","updated":"2017-09-05T06:01:04.000Z","comments":true,"path":"2017/09/05/20170905-2/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/09/05/20170905-2/","excerpt":"","text":"window.open(url); 을 하면 새 창이 열린다.새 창을 열 때 헤더를 추가하려면 아래와 같이 하면 된다. 1234567891011121314let xhttp = new XMLHttpRequest();xhttp.open(\"GET\", url, true);xhttp.setRequestHeader(\"Content-type\", \"application/json\"]);xhttp.responseType = \"blob\";xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; // Typical action to be performed when the document is ready: window.open(URL.createObjectURL(xhttp.response)); &#125;&#125;;xhttp.send();","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"}],"tags":[{"name":"window.open","slug":"window-open","permalink":"https://kkapkkapchu.github.io/blog/tags/window-open/"},{"name":"add_header","slug":"add-header","permalink":"https://kkapkkapchu.github.io/blog/tags/add-header/"}]},{"title":"Object 의 key/value 값 가져오기","slug":"20170905","date":"2017-09-05T05:24:01.000Z","updated":"2017-09-05T05:38:23.000Z","comments":true,"path":"2017/09/05/20170905/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/09/05/20170905/","excerpt":"","text":"Object 의 key 값 가져오기123456let requestHeaderObject = &#123; key1: value1, key2: value2,&#125;;console.log(Object.keys(requestHeaderObject)); // [\"key1\", \"key2\"] Object.keys 안에 key 값을 가져올 객체를 넣으면 객체의 key 값이 배열로 떨어진다. value 를 가져올 때는 객체의 key 배열을 돌면서 value 를 가져오면 된다. Object 의 value 값 가져오기1234567891011let requestHeaderObject = &#123; key1: value1, key2: value2,&#125;;Object.keys(requestHeaderObject).map((value) =&gt; &#123; console.log(value, requestHeaderObject[value]);&#125;);// key1 value1// key2 value2","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"}],"tags":[{"name":"object","slug":"object","permalink":"https://kkapkkapchu.github.io/blog/tags/object/"},{"name":"key/value","slug":"key-value","permalink":"https://kkapkkapchu.github.io/blog/tags/key-value/"}]},{"title":"마우스 우클릭 이벤트와 좌클릭 이벤트 구분하기","slug":"20170828","date":"2017-08-28T07:22:44.000Z","updated":"2017-09-05T06:04:41.000Z","comments":true,"path":"2017/08/28/20170828/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/28/20170828/","excerpt":"","text":"리액트에서 onTouchTap 을 사용했을 때 마우스 우클릭을 하면 처음에는 이벤트 호출이 안되는데,두 번째 우클릭부터는 onTouchTap 이벤트가 호출된다.(onClick 은 무조건 마우스 좌클릭만 호출된다.) 스크립트에서 마우스 우클릭과 좌클릭을 구분해야 할 때는 onClick 이나 onTouchTap 이 아닌 onMouseDown 이나 onMouseUp 이벤트를 사용해야 한다. 12345handleMouseUp = (event) =&gt; &#123; console.log(event.button) // 1: left, 2: right&#125;&lt;button onMouseUp=&#123;this.handleMouseUp&#125;&gt;마우스 클릭이벤트 구분&lt;/button&gt;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"}],"tags":[{"name":"mouse_click_event","slug":"mouse-click-event","permalink":"https://kkapkkapchu.github.io/blog/tags/mouse-click-event/"},{"name":"onTouchTap","slug":"onTouchTap","permalink":"https://kkapkkapchu.github.io/blog/tags/onTouchTap/"}]},{"title":"input 에서 마우스 커서 위치 얻어오기 및 변경하기","slug":"20170829","date":"2017-08-28T07:22:44.000Z","updated":"2017-08-29T07:36:32.000Z","comments":true,"path":"2017/08/28/20170829/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/28/20170829/","excerpt":"","text":"input 요소의 마우스 커서 위치 얻어오기1234567891011121314151617181920/** * 커서의 위치를 반환합니다. */getCaretPosition = () =&gt; &#123; let targetElement = this.refs.input; if (document.selection) &#123; // IE &lt; 9 targetElement.focus(); let range = document.selection.createRange(); let rangeLength = range.text.length; range.moveStart('character', -targetElement.value.length); let start = range.text.length - rangeLength; return &#123;'start': start, 'end': start + rangeLength&#125;; &#125; else if (targetElement.selectionStart || targetElement.selectionStart == '0') &#123; // IE &gt;= 9 and Other Browsers return &#123;'start': targetElement.selectionStart, 'end': targetElement.selectionEnd&#125;; &#125; else &#123; return &#123;'start': 0, 'end': 0&#125;; &#125;&#125;; input 요소의 마우스 커서 위치 변경하기1234567891011121314151617/** * 커서의 위치를 지정합니다. */setCaretPosition = (start, end) =&gt; &#123; let targetElement = this.refs.input; if (targetElement.setSelectionRange) &#123; // IE &gt;= 9 and Other Browsers targetElement.focus(); targetElement.setSelectionRange(start, end); &#125; else if (targetElement.createTextRange) &#123; // IE &lt; 9 let range = targetElement.createTextRange(); range.collapse(true); range.moveEnd('character', end); range.moveStart('character', start); range.select(); &#125;&#125;;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"}],"tags":[{"name":"mouse_cursor_get","slug":"mouse-cursor-get","permalink":"https://kkapkkapchu.github.io/blog/tags/mouse-cursor-get/"},{"name":"mouse_cursor_set","slug":"mouse-cursor-set","permalink":"https://kkapkkapchu.github.io/blog/tags/mouse-cursor-set/"},{"name":"caret_position","slug":"caret-position","permalink":"https://kkapkkapchu.github.io/blog/tags/caret-position/"}]},{"title":"propTypes 에 array 타입으로 지정할 때 array 안에 들어가는 값에 대한 타입 지정하기","slug":"20170825","date":"2017-08-25T04:22:54.000Z","updated":"2017-09-05T06:04:41.000Z","comments":true,"path":"2017/08/25/20170825/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/25/20170825/","excerpt":"","text":"React 에서 속성의 타입을 정의할 때 propTypes를 사용하면 편하다.속성의 타입이 array 라면 배열 안의 값에 대한 타입도 arrayOf()로 지정할 수 있다. 아래 예시는 배열 안의 값의 타입을 숫자로 정의한 것이다.12// An array of a certain typeoptionalArrayOf: PropTypes.arrayOf(PropTypes.number), 배열 안의 값의 타입을 PropTypes.number 로 지정했기 때문에 숫자말고 다른 타입이 들어오면 에러가 난다.부모 컴포넌트에서 넘어오는 속성 값은 숫자로 된 배열이어야 한다. (ex) optionalArrayOf=[1, 2, 3]) 이외에도 아래와 같이 많은 타입을 정의할 수 있도록 제공된다. 제공되는 PropTypes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // You can declare that a prop is a specific JS primitive. By default, these // are all optional. optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // Anything that can be rendered: numbers, strings, elements or an array // (or fragment) containing these types. optionalNode: PropTypes.node, // A React element. optionalElement: PropTypes.element, // You can also declare that a prop is an instance of a class. This uses // JS's instanceof operator. optionalMessage: PropTypes.instanceOf(Message), // You can ensure that your prop is limited to specific values by treating // it as an enum. optionalEnum: PropTypes.oneOf(['News', 'Photos']), // An object that could be one of many types optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // An array of a certain type optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // An object with property values of a certain type optionalObjectOf: PropTypes.objectOf(PropTypes.number), // An object taking on a particular shape optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // You can chain any of the above with `isRequired` to make sure a warning // is shown if the prop isn't provided. requiredFunc: PropTypes.func.isRequired, // A value of any data type requiredAny: PropTypes.any.isRequired, // You can also specify a custom validator. It should return an Error // object if the validation fails. Don't `console.warn` or throw, as this // won't work inside `oneOfType`. customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // You can also supply a custom validator to `arrayOf` and `objectOf`. // It should return an Error object if the validation fails. The validator // will be called for each key in the array or object. The first two // arguments of the validator are the array or object itself, and the // current item's key. customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; 참고사이트: https://facebook.github.io/react/docs/typechecking-with-proptypes.html","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"},{"name":"React","slug":"Web/JavaScript/React","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/React/"}],"tags":[{"name":"propTypes","slug":"propTypes","permalink":"https://kkapkkapchu.github.io/blog/tags/propTypes/"},{"name":"array","slug":"array","permalink":"https://kkapkkapchu.github.io/blog/tags/array/"}]},{"title":"keycode 라이브러리 사용시 키보드 오른쪽 keypad 숫자 가져오기","slug":"20170817","date":"2017-08-17T02:01:12.000Z","updated":"2017-08-28T07:41:55.000Z","comments":true,"path":"2017/08/17/20170817/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/17/20170817/","excerpt":"","text":"keycode 라이브러리를 사용해서 값을 가져오고 숫자만 뽑아내기 위해서 정규식을 쓰는 경우가 있다.이때 조심해야 하는 경우가 있는데 바로 키보드 오른쪽의 keypad 로 입력했을 때이다. IE에서는 keypad 로 숫자 입력시 keycode 라이브러리로 값을 가져오면 “numpad 숫자” 로 찍힌다.그래서 숫자 정규식을 쓰려면 숫자만 뽑아내야 한다. 123456789import keycode from 'keycode'// 맨 뒤의 숫자만 가져오기// console.log(keycode(event)); // IE: \"numpad 숫자\", Others: \"숫자\"let keycodeStr = keycode(event).slice(-1);// 숫자만인지 체크하는 정규식const regNumber = /^[0-9]*$/;if ( !regNumber.test(keycodeStr) ) return;","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"},{"name":"library","slug":"Web/JavaScript/library","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/library/"}],"tags":[{"name":"IE","slug":"IE","permalink":"https://kkapkkapchu.github.io/blog/tags/IE/"},{"name":"keycode","slug":"keycode","permalink":"https://kkapkkapchu.github.io/blog/tags/keycode/"}]},{"title":"HTML 요소 동적으로 생성하고 속성(Attribute) 추가하기","slug":"20170813","date":"2017-08-13T07:18:27.000Z","updated":"2017-08-28T07:41:55.000Z","comments":true,"path":"2017/08/13/20170813/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/13/20170813/","excerpt":"","text":"요소를 동적으로 생성하고 원하는 위치에 붙이기12345678// 요소 동적 생성let div = document.createElement(\"div\");// 원하는 위치에 붙인다document.body.appendChild(div);// React 에서는 요소를 붙이고 싶은 위치를 ref 로 잡아서도 가능 this.refs.test.appendChild(div); 동적으로 생성한 요소에 속성(Attribute) 추가하기1234567891011// 요소 동적 생성let div = document.createElement(\"div\");// 속성을 추가한다div.setAttribute(\"style\", \"width: 100%; height: 100%;\")// 원하는 위치에 붙인다document.body.appendChild(div);// React 에서는 요소를 붙이고 싶은 위치를 ref 로 잡아서도 가능 this.refs.test.appendChild(div); div.setAttribute(“style”, “width: 100%; height: 100%;”) 에서 첫 번째 인자가 추가할 속성의 이름이고,두 번째 인자가 추가할 속성의 값이다. 동적으로 생성한 요소에 이벤트 속성 추가하기12345678// 요소 동적 생성let a = document.createElement(\"a\");if (a.addEventListener) &#123; a.addEventListener('click', handler, false); &#125; else if (el.attachEvent) &#123; a.attachEvent('onclick', handler);&#125; onclick, onblur 와 같은 이벤트 속성을 추가하고 싶을 때는 setAttribute 가 아닌 addEventListener 로 하면 된다. 동적으로 생성한 요소 삭제하기12345&lt;ul id=\"myList\"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 위의 예제처럼 ul, li 태그가 생성되었다고 할 때, li 태그를 지우고 싶으면 아래 예제처럼 하면 된다.12345678// 삭제할 요소의 상위(부모) 요소let myNode = document.getElementById(\"myList\");// 원하는 자식 요소만 지우기myNode.removeChild(myNode.childNodes[0]);// 자식 요소들 한번에 지우기myNode.innerHTML = '';","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/JavaScript/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://kkapkkapchu.github.io/blog/tags/HTML/"}]},{"title":"CSS에서 calc 함수 중첩해서 쓰기","slug":"20170803","date":"2017-08-03T11:31:27.000Z","updated":"2017-08-04T00:31:59.000Z","comments":true,"path":"2017/08/03/20170803/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/08/03/20170803/","excerpt":"","text":"Calc() function inside another calc() in CSS123456789// for Chrome, IE 9div&#123; width: calc(100% - (1% + 30px)); /* calc(1% + 30px) is nested inside calc() */&#125;// for Chromediv p&#123; width: calc(100% - calc(1% + 30px));&#125; 크롬은 둘 다 지원하지만 IE는 첫 번째만 지원한다.IE에서 calc 함수를 중첩으로 사용하려면 맨 앞에 calc로 한번만 감싸야한다. 이를 위해서 안의 중첩된 calc 글자를 없애주는 라이브러리(reduce-css-calc)도 있는거 같은데,이 라이브러리 안에서 쓰이는 “fs” 라이브러리가 없어진듯 하다… 그래서 못씀.. 아무튼 해결법은 calc를 한번만 사용하도록 식을 바꾸든지, 중첩된 calc 를 계산해서 숫자로 바꿔주는 라이브러리를 만들든지 찾든지 해야한다.","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"CSS","slug":"Web/CSS","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/CSS/"}],"tags":[{"name":"IE","slug":"IE","permalink":"https://kkapkkapchu.github.io/blog/tags/IE/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-24T06:31:27.000Z","updated":"2018-07-07T14:01:08.000Z","comments":true,"path":"2017/07/24/hello-world/","link":"","permalink":"https://kkapkkapchu.github.io/blog/2017/07/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Generate And Deploy1$ hexo g -d","categories":[{"name":"Web","slug":"Web","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"https://kkapkkapchu.github.io/blog/categories/Web/Hexo/"}],"tags":[]}]}